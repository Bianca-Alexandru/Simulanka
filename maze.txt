ENVIRONMENT {
    width: 21
    height: 21
    steps: 1
}

SPECIES {
    ROUTINE connect_logic {
        i = 0;
        while (i < 2) {
            if (self.genes[i] > 50) {
                self.connected[i] = 1;
            } else {
                self.connected[i] = 0;
            }
            i = i + 1;
        }
    }
    mazecell {
        // genes represent walls to [up, left]
        genes: [random(0, 51), random(0, 51)],
        connected: [0, 0],
        visited: 0,
        dist: 0,
        parent_x: 0,
        parent_y: 0,
        is_path: 0,
        routine: connect_logic
    }
}

SPAWN {
    i = 0;
    while (i < 21) {
        j = 0;
        while (j < 21) {
            spawn mazecell @ (i, j);
            j = j + 1;
        }
        i = i + 1;
    }
}

FITNESS {
    if (self.x == 0) {
        if (self.y == 0) {
            for cell in environment {
                cell.visited = 0;
                cell.is_path = 0;
                cell.dist = 0;
            }
            
            queue = [];
            start_node = get_at(0, 0);
            if (start_node != 0) {
                push(queue, start_node);
                start_node.visited = 1;
                start_node.dist = 0;
            }
            
            head = 0;
            reached_goal = 0;
            min_dist_to_goal = 100;
            max_d = 0;
            
            while (head < len(queue)) {
                curr = queue[head];
                head = head + 1;

                dx = 20 - curr.x;
                dy = 20 - curr.y;
                if (dx < 0) { dx = 0 - dx; }
                if (dy < 0) { dy = 0 - dy; }
                d_to_g = dx + dy;
                if (d_to_g < min_dist_to_goal) {
                    min_dist_to_goal = d_to_g;
                }

                if (curr.x == 20) {
                    if (curr.y == 20) {
                        reached_goal = 1;
                        max_d = curr.dist; 
                    }
                }
                
                k = 0;
                while (k < 4) {
                    nx = curr.x;
                    ny = curr.y;
                    if (k == 0) { ny = ny - 1; } // up
                    if (k == 1) { ny = ny + 1; } // down
                    if (k == 2) { nx = nx - 1; } // left
                    if (k == 3) { nx = nx + 1; } // right
                    
                    if (nx > -1) {
                        if (nx < 21) {
                            if (ny > -1) {
                                if (ny < 21) {
                                    next = get_at(nx, ny);
                                    if (next != 0) {
                                        if (next.visited == 0) {
                                            blocked = 0;
                                            if (k == 0) { if (curr.connected[0] == 1) { blocked = 1; } }
                                            if (k == 1) { if (next.connected[0] == 1) { blocked = 1; } }
                                            if (k == 2) { if (curr.connected[1] == 1) { blocked = 1; } }
                                            if (k == 3) { if (next.connected[1] == 1) { blocked = 1; } }
                                            
                                            if (blocked == 0) {
                                                next.visited = 1;
                                                next.dist = curr.dist + 1;
                                                next.parent_x = curr.x;
                                                next.parent_y = curr.y;
                                                push(queue, next);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    k = k + 1;
                }
            }
            
            reachable = head;
            
            if (reached_goal == 0) {
                score = (40 - min_dist_to_goal) * 100 + (reachable * 10);
                
                // critical: clear heavy temporary variables to prevent memory bloat in history
                queue = []; 
                start_node = 0; curr = 0; next = 0;
                
                return score;
            }

            if (reached_goal == 1) {
                total_walls = 0;
                for c in environment {
                    if (c.connected[0] == 1) { total_walls = total_walls + 1; }
                    if (c.connected[1] == 1) { total_walls = total_walls + 1; }
                }

                score = 100000 + (max_d * max_d * 10) + (total_walls * 1) + (reachable * 500);

                temp = get_at(20, 20);
                while (temp != 0) {
                    temp.is_path = 1;
                    if (temp.x == 0 && temp.y == 0) { temp = 0; }
                    else { temp = get_at(temp.parent_x, temp.parent_y); }
                }
                
                // critical: clear heavy temporary variables to prevent memory bloat in history
                queue = []; 
                start_node = 0; curr = 0; next = 0; temp = 0;
                
                return score;
            }
        }
    }
    return 0;
}

MUTATE {
    crossover: {
        i = 0;
        while (i < 2) {
            if (random(0, 2) == 0) {
                child.genes[i] = parent1.genes[i];
            } else {
                child.genes[i] = parent2.genes[i];
            }
            i = i + 1;
        }
    }
    
    mutation: {
        if (random(0, 100) < 15) { 
            idx = random(0, 2);
            self.genes[idx] = self.genes[idx] + random(0, 21) - 10;
            
            if (self.genes[idx] < 0) { self.genes[idx] = 0; }
            if (self.genes[idx] > 100) { self.genes[idx] = 100; }
        }
    }
}

VISUALIZE {
    cell_size = 26;
    offset = 25;
    
    for cell in environment {
        vx = offset + cell.x * cell_size;
        vy = offset + cell.y * cell_size;
        
        draw_circle(vx, vy, 2, 50, 50, 255);
        if (cell.x == 20) { draw_circle(vx + cell_size, vy, 2, 50, 50, 255); }
        if (cell.y == 20) { draw_circle(vx, vy + cell_size, 2, 50, 50, 255); }
        if (cell.x == 20) { if (cell.y == 20) { draw_circle(vx + cell_size, vy + cell_size, 2, 50, 50, 255); } }

        if (cell.connected[0] == 1) {
            draw_line(vx, vy, vx + cell_size, vy, 255, 255, 0, 2);
        }
        if (cell.connected[1] == 1) {
            draw_line(vx, vy, vx, vy + cell_size, 255, 255, 0, 2);
        }
        
        if (cell.is_path == 1) {
            cx = vx + cell_size / 2;
            cy = vy + cell_size / 2;
            px = offset + cell.parent_x * cell_size + cell_size / 2;
            py = offset + cell.parent_y * cell_size + cell_size / 2;
            if (cell.x == 0 && cell.y == 0) {
            } else {
                draw_line(cx, cy, px, py, 255, 0, 0, 4); 
            }
        }

        if (cell.x == 0 && cell.y == 0) {
            draw_circle(vx + cell_size / 2, vy + cell_size / 2, cell_size / 3, 0, 255, 0);
        }
        if (cell.x == 20 && cell.y == 20) {
            draw_circle(vx + cell_size / 2, vy + cell_size / 2, cell_size / 3, 255, 0, 0);
        }
    }
    
    draw_line(offset, offset, offset + 21 * cell_size, offset, 255, 255, 255, 2);
    draw_line(offset + 21 * cell_size, offset, offset + 21 * cell_size, offset + 21 * cell_size, 255, 255, 255, 2);
    draw_line(offset + 21 * cell_size, offset + 21 * cell_size, offset, offset + 21 * cell_size, 255, 255, 255, 2);
    draw_line(offset, offset + 21 * cell_size, offset, offset, 255, 255, 255, 2);
}

EVOLVE {
    generations: 5000,
    instances: 20
}